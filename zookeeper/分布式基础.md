# 分布式基础

任何在设计阶段考虑到的异常情况，一定会在系统实际运行中发送，并且，在系统实际运行过程中还会遇到很多在设计时未能考虑到的异常故障。

## 概念
### ACID
* 原子性（Atomicity）
* 一致性（Consistency）
* 隔离项（Isolation）
* 持久性（Durability）


### CAP
一个分布式系统不可能同时满足
* 一致性(C:Consistency)
* 可用性（A:Availability）
* 分区容错性（P:Partition tolerance）
这三个基本需求，最多只能同时满足其中的两项

对一个分布式系统而言，分区容错性是一个基本要求。一般是根据业务特性在C和A直接寻求平衡

什么是高可用？可用性的判断标准是啥？
高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。  

高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间都是可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。

### BASE
* 基本可用（basically available)
* 软状态（soft state）
* 最终一致性（eventually consistent）

ACID属于强一致性模型，BASE通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。

## 一致性协议

### 2PC 二阶段提交
协调者（Coordinator）
参与者（Participant）
二阶段提交将一个事务的处理方式分为了投票和执行两个阶段，可以看做一个强一致性算法
优点
* 原理简单，实现方便

确定
* 同步阻塞
* 单点问题 协调者是单点
* 数据不一致（脑裂） commit请求未送达所有参与者
* 太过保守 协调组仅能依靠超时机制判断是否需要终端事务，没有较为完善的容错机制，任意一个节点的失败会导致整个事务的失败

### 3PC 三阶段提交
1. CanCommit
2. PreCommit
3. do Commit


一个分布式算法有两个最重要的属性：安全性（Safety）和活性（Liveness）
Safety是指那些需要保证永远不会发送的事情。
Liveness是指那些最终一定会发生的事情。

## Chubby
中心化部署的分布式所服务，而非仅仅是一个一致性协议的客户端库

客户端成功获取到一个Chubby文件锁，成为Master，向文件里写入Master信息，其他客户端通过读取这个文件得知当前的Master信息

Master租期，租约形式：通过不断续租来延长Master租期

虚拟时间 虚拟同步

Master失效检测
Master选举
Master重新选举对客户端的平滑过渡
客户端缓存一致性

从节点恢复后数据恢复，快照+回放

## Consistency概念

* Sequential Consistency
* Causal Consistency
* Linearizability