# basic knowledge
## paxos 算法流程
Paxos算法分为两个阶段。具体如下：

阶段一：

(a) Proposer选择一个**提案编号N**，然后向半数以上的Acceptor发送编号为N的**Prepare请求**。

(b) 如果一个Acceptor收到一个编号为N的Prepare请求，且N**大于**该Acceptor已经**响应过的**所有**Prepare请求**的编号，那么它就会将它已经**接受过的编号最大的提案（如果有的话）**作为响应反馈给Proposer，同时该Acceptor承诺**不再接受**任何**编号小于N的提案**。

阶段二：

(a) 如果Proposer收到**半数以上**Acceptor对其发出的编号为N的Prepare请求的**响应**，那么它就会发送一个针对**[N,V]提案**的**Accept请求**给**半数以上**的Acceptor。注意：V就是收到的**响应**中**编号最大的提案的value**，如果响应中**不包含任何提案**，那么V就由Proposer**自己决定**。

(b) 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor**没有**对编号**大于N**的Prepare请求做出过响应，它就**接受该提案**。

如何保证Paxos算法的活性？

通过选取主Proposer，就可以保证Paxos算法的活性。至此，我们得到一个既能保证安全性，又能保证活性的分布式一致性算法——Paxos算法。

每个Acceptor都会把accept的值告诉给learner，learner收到大多数acceptors的值，就知道这个值被选定了

少数派的值不会被修正，learner只会learn到被多数派accept的值

prepare阶段有两个作用，一是尝试获取提议权，二是学习已经提议过的value，都不需要携带自己的value



acceptor只要响应了N+1的prepare请求，就不能accept N的提案
一个Acceptor只需记住：1. 已接受的编号最大的提案 2. 已响应的请求的最大编号。


value被majority accept之前，每个acceptor可以accept多个不同的值。但是，一旦一个value被majority accept(即value达成一致)，那么这个value就不会变了。

从流程中可以看出prepare有两个作用:

1. 大的proposal id会block未完成的小的proposal id达成一致的过程，所以为了减少无效的prepare请求，每次都选择比自己以往见过的proposal id更大的id。  

2. 一旦某个value达成一致，那么后续的prepare都会找到这个value作为accept阶段的值

可以看出，一次paxos达成一致至少需要两次网络交互。


## 不太完美的复制策略
### 主从异步复制

客户端收到一个数据已经安全(OK)的信息, 跟数据真正安全(数据复制到全部的机器上)在时间上有一个空隙, 这段时间负责接收客户端请求的那个机器可能损坏，导致数据丢失


### 主从同步复制

整个系统中有任何一个机器宕机, 写入就进行不下去了. 相当于系统的可用性随着副本数量指数降低.


### 主从半同步复制

它要求master在应答客户端之前必须把数据复制到足够多的机器上, 但不需要是全部. 这样副本数够多可以提供比较高的可靠性; 1台机器宕机也不会让整个系统停止写入.

但是它还是不完美, 例如数据a复制到slave-1, 但没有到达slave-2; 数据b复制达到了slave-2但没有到达slave-1, 这时如果master挂掉了需要从某个slave恢复出数据, 任何一个slave都不能提供完整的数据. 所以在整个系统中, 数据存在某种**不一致**.


### 多数派写（读）
每条数据必须写入到半数以上的机器上. 每次读取数据都必须检查半数以上的机器上是否有这条数据.

在这种策略下, 数据可靠性足够, 宕机容忍足够, 任一机器故障也能读到全部数据.

但是，对于一条数据的更新时, 会产生**不一致**的状态. 例如:

node-1, node-2都写入了a=x,
下一次更新时node-2, node-3写入了a=y.
这时, 一个要进行读取a的客户端如果联系到了node-1和node-2, 它将看到2条不同的数据.

为了不产生歧义, 多数派读写还必须给每笔写入增加一个全局递增的时间戳. 更大时间戳的记录如果被看见, 就应该忽略小时间戳的记录. 这样在读取过程中, 客户端就会看到a=x₁, a=y₂ 这2条数据, 通过比较时间戳1和2, 发现y是更新的数据, 所以忽略a=x₁. 这样保证多次更新一条数据不产生歧义.

即最后一次写入覆盖先前的写入。所有写入操作需要有一个全局顺序：时间戳。

但是，这种带时间戳的多数派读写依然有问题. 就是在客户端没有完成一次完整的多数派写的时候: 例如,, a=x₁写入了node-1和node-2, a=y₂时只有node-3 写成功了, 然后客户端进程就挂掉了, 留下系统中的状态如下:
```
node-1:a=x1
node-2:a=x1
node-3:a=y2
```

这时另一个读取的客户端来了,

如果它联系到node-1和node-2, 那它得到的结果是a=x₁.
如果它联系到node-2和node-3, 那它得到的结果是a=y₂.

整个系统对外部提供的信息仍然是不一致的.

一致性：最终一致性
事务性：非原子更新  脏读  更新丢失问题

paxos可以认为是多数派读写的进一步升级, paxos中通过2次原本并不严谨的多数派读写, 实现了严谨的强一致consensus算法.

**paxos：一个系统最多只能允许一个多数派写成功.**

paxos核心算法中只解决网络延迟/乱序的问题, 它不试图解决存储不可靠和消息错误的问题

Classic Paxos：1个实例（确定一个值）写入需要2轮RPC

Multi Paxos：约为1轮RPC，确定一个值（第一次RPC做了合并）

Fast Paxos：没冲突，1轮RPC确定一个值。有冲突，2轮RPC确定一个值



一个分布式算法有两个最重要的属性：安全性（Safety）和活性（Liveness）
Safety是指那些需要保证永远不会发送的事情。
Liveness是指那些最终一定会发生的事情

Paxos解决了无限期等待问题，也解决了脑裂问题。